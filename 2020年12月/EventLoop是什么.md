# Event Loop 是什么？

<!-- TODO: 本文写于 2020 年 12 月 -->

Event Loop 并不是 JavaScript 独有的概念，他是一个计算机的通用概念。

为什么需要 Event Loop 呢？先看一个常见的场景，如果我们同时执行了三种不同的异步事件：

```js
setTimeout(foo, 100);
fs.readFile('./README.md', bar);
server.on('close', doSth);
```

我们知道在计算机中，操作系统会帮我们新建一个「进程」使应用程序可以执行，但是**一个进程在一个时刻只能执行一个任务**，如果我们需要同时执行这三个任务，有三个方法：

1. 新建一个进程；
2. 新建一个线程；
3. 排队执行。

如果不太了解，可以看我之前的一篇文章，「进程与线程」。

JavaScript 作为一门**单线程**的语言，肯定不能分出三条线程去执行这三条语句。那么设计时器结束的一瞬间，三个回调函数**同时触发**了，Node 会怎么处理呢？

我们可以推测出以下两点：

1. Node 肯定会以某种顺序执行；
2. 这种顺序应该是规定好的（优先级）。

回到 Event Loop 本身，我们拆开来看看。什么叫做 Event？Event 就是事件，比如回调函数的触发就是一个事件。什么叫做 Loop？Loop 就是循环，比如 for 循环 while 循环。

**事件是有优先级的，所以处理时候是分先后的。**Node.js 按照顺序去“询问”每个 Event，并且循环往复的去“询问”：Event1 => Event2 => Event3 => Event1 => Event2 => ...这就变成了 **「poll（轮询）」**。

**操作系统触发事件，JavaScript 处理事件，Event Loop 就是对事件处理顺序的管理方案。**

```
     |-----------------------|
---->|         timer         |
|    |-----------------------|
|                |
|                |
|    |-----------------------|
|    |    close callbacks    |
|    |-----------------------|
|                |
|                |
|    |-----------------------|
|    |     idle, prepare     |
|    |-----------------------|
|                |
|                |                 |------------------|
|    |-----------------------|     |     incoming:    |
|    |          poll         |<----|    connections,  |
|    |-----------------------|     |     data, etc.   |
|                |                 |------------------|
|                |
|    |-----------------------|
|    |         check         |
|    |-----------------------|
|                |
|                |
|    |-----------------------|
-----|    close callbacks    |
     |-----------------------|
```

这是 Node.js 官方文档上的示意图，我们来分析一下。

- 首先第一步，看是否存在计时器；
- 然后在看有没有其他的 I/O 相关的回调函数；
- idle 和 prepare 阶段根据字面意思推断，应该是清理一下，休息一下；
- 下一步进入轮询的阶段，检查系统事件；
- check 阶段检查 setImmediate 回调；
- close callbacks 就是处理类似 socket 关闭的事件。

其中，最常用的就是：timer 检查、poll 轮询、check 检查。

并且**大部分时间，Node.js 都停留在 poll 阶段**，文件请求、网络请求的事件处理也多半在这个阶段进行。所以 Node.js 会很智能的在其他阶段空闲时只停留在该阶段。
