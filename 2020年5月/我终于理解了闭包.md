# 我终于理解了闭包

本文写于 2020 年 5 月 14 日

闭包这个词一听就很高级，令人害怕。

但实际上，闭包非常的强大，JS 的精髓之一就是闭包。

更重要的是我们经常在使用闭包，而不自知！闭包并没有传闻中的那么困难。（其实所有的知识都是这样，难者不会，会者不难）

Kyle Simpson 在书中将掌握闭包，比喻为：

> 不像 Luke 一样接受训练才能掌握原力，而是像 Neo 见到矩阵一样。

我们其实一直都在不自觉地使用着闭包，一旦理解了闭包，就会如同重生一般，凤凰涅槃。

首先，一言以蔽之：**一个持有外部环境变量的函数就是闭包。**

## 函数的作用域

说到外部环境变量，那么就必然要谈到**作用域**。

我们来看一段程序：

```javascript
function foo() {
  let hello = 'hello world';
  console.log(hello);
}
```

这个非常简单的函数，如果调用 `foo()` ，那么在短暂的时间过后，hello 变量就会消失的无影无踪，仿佛从来没有出现过一样。

这就说明，在 `foo()` 执行结束之后，内部的作用域销毁了，或者说我们找不到内部作用域了。

但是如果这么写：

```javascript
function foo() {
  let hello = 'hello world';
  function bar() {
    console.log(hello);
  }
  return bar;
}

let hey = foo();
```

观察一下，虽然在`let hey = foo()`的时候，`foo` 已经执行过了，但是如果我们使用`hey()`，依然可以使用 hello 变量！

**这就是闭包。**

`foo()`在执行之后，正常情况下，整个内部的作用域都会被销毁，因为 JS 引擎会帮助我们自动回收垃圾。

而闭包神奇的可以阻止这件事情的发生，让内部作用域依然存在，不被回收，并且在这个例子中，可以让 `bar()` 来访问 `foo` 的内部作用域。

`bar()` 在 `foo()` 执行结束后，依然**保持了对该作用域的引用**，这就叫做闭包！

## 我们经常都在使用闭包

上面的代码是不是十分眼熟？感觉似曾相识但从来没有主动的去写过。

那我们接下来看个例子，他也是闭包：

```javascript
function foo() {
  const hello = 'hello world';
  setInterval(function bar() {
    alert(hello);
  }, 1000);
}
```

这个 `setInterval` 定时器，是不是闭包？

**定时器、事件监听器、Ajax 请求、跨窗口通信……只要用到了回调函数，都是闭包！**

原来的时候闭包还有一个用处，就是关于 for 循环的 i 泄漏问题。这是以前 ES5 的时候，大家一直有个困惑：

```javascript
for (var i = 0; i < 5; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000 * i);
}
```

为什么这个代码每个一秒会输出一次 5？

就算输出也应该是 4 啊，为什么呢？

因为 var 的 i，作用域其实**在外面**。

那也就是说，其实**只有一个 i**，并且在最后一次结束的时候，**i 已经是 5 了**。

而异步操作，都是在 **`for` 循环结束之后才执行的**。

也就是说，每次循环结束，都会记住`setTimeout(() => { console.log(i) }, n000)`，然后在 `for` 结束之后，统一的把 i 传入 `console`。

那自然而然的，会都输出 5 了。

那这个怎么让他每一次循环都能够实现，`console` 对当前 i 的引用呢？这也是闭包呀。

把 `setTimeout` 单独放到一个作用域里，然后再循环的时候把当前的 i 传进去就可以了！非常简单！

```javascript
for (var i = 0; i < 5; i++) {
  (function (j) {
    setTimeout(() => {
      console.log(j);
    }, 1000 * j);
  })(i);
}
```

成功了！

但实际上，如果使用 let，完全不会有这种需要“泄露”的情况。

此文简单分析了一下闭包，并没有深入讨论，只是经常看到有很多人将闭包说的很难——**其实闭包我们一直在用，而不自知**。

（完）
