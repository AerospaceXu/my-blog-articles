# Go 语言并发入门

本文写于 2021 年 2 月 1 日

因为我之前并没有怎么接触过并发编程，C 和 Python 都只是做了一点学术用途，真正用于生产环境的 JS 又没有并发可言，所以这次来细细的学习一下 Golang 的并发。

**目录：**

- 简单介绍 Go 的并发
- 锁机制

## 简单介绍 Go 的并发

Go 语言生来就是容易实现并发的，我们只需要通过 `go` 关键字来开启 `goroutine` 即可。

同一个程序中的所有 `goroutine` 共享同一个地址空间。

`goroutine` 是**轻量级线程，叫做协程**，其调度是由 Golang 运行时进行管理的。也就是说两个协程可能是两个线程，也可能是一个线程。

这通常也称为 M:N 线程模型——因为我们有 M 个应用线程（ 协程 ）运行在 N 个操作系统线程上。在现代的硬件上，有可能拥有数百万个协程。

```go
go foo(...params)
```

比如一个很简单的例子：

```go
package main

import (
  "fmt"
  "time"
)

func say(s string) {
  for i := 0; i < 5; i++ {
    time.Sleep(100 * time.Millisecond)
    fmt.Println(s)
  }
}

func main() {
  go say("world")
  say("hello")
}
```

这样一条程序就会是由主线程和 `goroutine` 同时执行的程序。

但是如果我们尝试做一个小小的修改呢？比如，删掉这一句 `Sleep`。

我们惊讶的发现，一旦删除了 `Sleep`，整个的就会出现问题：次数不对。

如果我们的函数是输出 10 次 xxx：

```go
func foo() {
  for i := 0; i < 100; i++ {
    fmt.Println("xxx")
  }
}

func main() {
  go foo()
  foo()
}
```

那么我们并发执行的时候就会发现**次数不对**，他居然只执行了十次！

可我们的并发执行不应该是 20 次吗？就算不并发也应该是 20 次呀。

更奇怪的是当我们将次数增加到 100 次的时候，又会发现他确实是执行了一百多次，虽然数不清是否是 100 + 100 次。

这是为什么呢？

**因为 go 程序会在主线程结束之后结束，届时就算 goroutine 没有结束，他也得被干掉了。**主进程在退出前不会等待全部协程执行完毕。

## 锁机制

我们想像一个场景：有两个协程在同时读写一个数字，分别对它进行了 `+1` 和 `-1` 操作。

在操作的时候，我们会先去读取这个值，然后进行加减，最后把新值扔回去。

这就引发了一个问题：如果两个协程同时读取了最初始的数据，那么他们计算出的值就会分别是 `2` 和 `0`。那么谁后把值扔回去，该数字就会是哪个值。

这就需要一个锁的概念。

每当一个值**被一个协程所读取，就会上锁**，接下来不管谁读取都会遇到这个锁而无法读取。当操作完毕后，再解开这个锁即可。

编写并发代码要求特别注意在何时何处读取和写入一个值。

（完）
