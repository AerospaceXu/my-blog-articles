# Go 语言并发入门

本文写于 2021 年 2 月 1 日

因为我之前并没有怎么接触过并发编程，C 和 Python 都只是做了一点学术用途，真正用于生产环境的 JS 又没有并发可言，所以这次来细细的学习一下 Golang 的并发。

- [Go 语言并发入门](#go-语言并发入门)
  - [简单介绍 Go 的并发](#简单介绍-go-的并发)
    - [Go 开启协程](#go-开启协程)
  - [锁机制](#锁机制)

## 简单介绍 Go 的并发

Go 语言生来就是容易实现并发的，我们只需要通过 `go` 关键字来开启 `goroutine` 即可。

同一个程序中的所有 `goroutine` 共享同一个地址空间。

`goroutine` 是**轻量级线程，叫做协程**，其调度是由 Golang 运行时进行管理的。也就是说两个协程可能是两个线程，也可能是一个线程。

这通常也称为 M:N 线程模型——因为我们有 M 个应用线程（ 协程 ）运行在 N 个操作系统线程上（在现代的硬件上，有可能拥有数百万个协程）。但是为什么呢？为什么不用线程用协程呢？

因为虽然线程保证了操作系统级别的并发需求，但是**线程切换毕竟是有成本的**。打个比方，假设你的 CPU 使用率 100%，那可能 40% 的性能都用去切换线程了，浪费至极。

因此 Go 创造了一个协程调度器，在一个线程上自己调度多个协程，从而降低多线程的切换成本。

### Go 开启协程

Go 语言只需要用一个 `go` 关键字即可开启一个协程：

```go
go foo(...params)
```

以下是一个很简单的例子：

```go
package main

import (
  "fmt"
  "time"
)

func say(s string) {
  for i := 0; i < 5; i++ {
    time.Sleep(100 * time.Millisecond)
    fmt.Println(s)
  }
}

func main() {
  go say("world")
  say("hello")
}
```

这样一条程序就会是由主线程和 `goroutine` 同时执行的程序。他会在一条 `say` 的时间里，输出两条 `say` 的内容。

接下来我们尝试做一个小小的修改：删掉 `Sleep`。

再运行程序。

我们惊讶的发现，一旦删除了 `Sleep`，整个程序就会出现问题：**输出的次数不对**。

如果我们的函数是输出 10 次 xxx：

```go
func foo() {
  for i := 0; i < 100; i++ {
    fmt.Println("xxx")
  }
}

func main() {
  go foo()
  foo()
}
```

那么我们并发执行的时候就会发现**次数不对**，他居然只执行了十次！

可我们的并发执行不应该是 20 次吗？就算不并发也应该是 20 次呀。

更奇怪的是当我们将次数增加到 100 次的时候，又会发现他确实是执行了 100+ 次数，但是明显不足 200。

这是为什么呢？

**因为 go 程序会在主线程结束之后结束，届时就算 goroutine 没有结束，他也得被干掉了。**

**主进程在退出前不会等待全部协程执行完毕。**

## 锁机制

我们想像一个场景：有两个协程在同时读写一个数字，分别对它进行了 `+1` 和 `-1` 操作。

在操作的时候，我们会先去读取这个值，然后进行加减，最后把新值扔回去。

这就引发了一个问题：如果两个协程同时读取了最初始的数据，那么他们计算出的值就会分别是 `2` 和 `0`。那么谁后把值扔回去，该数字就会是哪个值。

这就需要一个锁的概念。

每当一个值**被一个协程所读取，就会上锁**，接下来不管谁读取都会遇到这个锁而无法读取。当操作完毕后，再解开这个锁即可。

编写并发代码要求特别注意在何时何处读取和写入一个值。

（完）
